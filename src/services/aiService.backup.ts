import { supabase } from '@/integrations/supabase/client';import { predictiveService, DeliveryPrediction } from './predictiveService';import { businessInsightsService } from './businessInsightsService';import { visualRecognitionService } from './visualRecognitionService';const OPENROUTER_API_KEY = "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";const MODEL = "kwaipilot/kat-coder-pro:free";// Helper functionstype OrderData = {  order_status?: string;  product_name?: string;  carrier_name?: string;  actual_delivery?: string;  expected_delivery?: string;  [key: string]: any;};function getStatusExplanation(status?: string): string {  if (!status) return 'Your order is being processed.';    const statusMap: Record<string, string> = {    'processing': 'Your order is being prepared for shipment.',    'shipped': 'Your order is on its way to you!',    'delivered': 'Your order has been delivered.',    'delayed': 'Your delivery is taking longer than expected.',    'out_for_delivery': 'Your package is with the delivery driver and should arrive soon!',    'exception': 'There is an issue with your delivery that needs attention.'  };  return statusMap[status.toLowerCase()] || 'Your order is being processed.';}function getNextExpectedAction(status?: string): string {  if (!status) return 'Please check back soon for updates.';    const actionMap: Record<string, string> = {    'processing': 'You will receive a shipping confirmation email soon.',    'shipped': 'Please track your package using the information above.',    'delivered': 'Please check your delivery location and with household members.',    'delayed': 'We are monitoring the situation and will update you soon.',    'out_for_delivery': 'Please ensure someone is available to receive the package.',    'exception': 'Our team is working to resolve this issue.'  };  return actionMap[status.toLowerCase()] || 'Thank you for your patience.';}function getQuickSummary(orderData?: OrderData): string {  if (!orderData) return 'Processing your request...';    const status = orderData.order_status?.toLowerCase() || '';  const product = orderData.product_name || 'your items';    switch(status) {    case 'processing':      return `We're preparing ${product} for shipment.`;    case 'shipped':      return `${product} is on the way with ${orderData.carrier_name || 'the carrier'}.`;    case 'delivered':      return `${product} was delivered on ${formatDate(orderData.actual_delivery)}.`;    case 'delayed':      return `Your delivery is delayed. New estimated delivery: ${formatDate(orderData.expected_delivery)}.`;    default:      return `Status: ${orderData.order_status || 'processing'}.`;  }}interface Order {  id: string;  order_id: string;  customer_name: string;  customer_email: string;  customer_phone: string;  customer_address: string;  customer_city: string;  customer_state: string;  customer_pincode: string;  customer_country: string;  product_id: string;  product_name: string;  product_category: string;  product_subcategory: string;  product_brand: string;  product_color: string | null;  product_size: string | null;  product_price: number;  quantity: number;  discount_percent: number;  discount_amount: number;  tax_amount: number;  shipping_fee: number;  total_amount: number;  order_status: string;  payment_method: string;  payment_status: string;  payment_id: string | null;  order_date: string;  confirmed_date: string | null;  packed_date: string | null;  shipped_date: string | null;  expected_delivery: string | null;  actual_delivery: string | null;  tracking_number: string | null;  carrier_name: string | null;  current_location: string | null;  seller_name: string;  seller_rating: number | null;  order_notes: string | null;  is_gift: boolean;  gift_message: string | null;  created_at: string;  updated_at: string;}function formatDate(dateString: string | null): string {  if (!dateString) return 'TBD';  return new Date(dateString).toLocaleDateString('en-IN', {     day: 'numeric',     month: 'short',     year: 'numeric'   });}function formatOrderForDisplay(order: Order): string {  return `üì¶ **Order: ${order.order_id}**- Customer: ${order.customer_name}- Email: ${order.customer_email}- Phone: ${order.customer_phone}- Address: ${order.customer_address}, ${order.customer_city}, ${order.customer_state} - ${order.customer_pincode}- Product: ${order.product_name} (${order.product_category})- Brand: ${order.product_brand}- Color: ${order.product_color || 'N/A'}- Size: ${order.product_size || 'N/A'}- Price: ‚Çπ${order.product_price} √ó ${order.quantity} = ‚Çπ${order.total_amount}- Status: ${order.order_status}- Payment: ${order.payment_method} (${order.payment_status})- Tracking: ${order.tracking_number || 'N/A'}- Carrier: ${order.carrier_name || 'N/A'}- Current Location: ${order.current_location || 'N/A'}- Order Date: ${formatDate(order.order_date)}- Expected Delivery: ${formatDate(order.expected_delivery)}${order.actual_delivery ? `- Delivered On: ${formatDate(order.actual_delivery)}` : ''}- Seller: ${order.seller_name}${order.seller_rating ? `- Seller Rating: ‚≠ê${order.seller_rating}/5` : ''}${order.order_notes ? `- Notes: ${order.order_notes}` : ''}${order.is_gift ? '- üéÅ This is a gift order' : ''}${order.gift_message ? `- Gift Message: ${order.gift_message}` : ''}  `.trim();}async function getRelevantOrderData(userMessage: string): Promise<string> {  const lowerMessage = userMessage.toLowerCase();  let results: string[] = [];    // Check for specific order ID  const orderIdMatch = lowerMessage.match(/od\d+/i);  if (orderIdMatch) {    const { data } = await supabase      .from('orders')      .select('*')      .ilike('order_id', `%${orderIdMatch[0]}%`)      .limit(1);        if (data && data.length > 0) {      results.push(`Found order:\n${formatOrderForDisplay(data[0])}`);    }  }  // Check for customer name search  const namePatterns = ["order for", "orders of", "track order of", "find order for", "orders by", "customer", "my order"];  for (const pattern of namePatterns) {    if (lowerMessage.includes(pattern)) {      const nameStart = lowerMessage.indexOf(pattern) + pattern.length;      const possibleName = userMessage.substring(nameStart).trim().split(/[,.\?!]/)[0].trim();      if (possibleName.length > 2) {        const { data } = await supabase          .from('orders')          .select('*')          .ilike('customer_name', `%${possibleName}%`)          .order('order_date', { ascending: false })          .limit(5);                if (data && data.length > 0) {          results.push(`Found ${data.length} order(s) for "${possibleName}":\n${data.map(formatOrderForDisplay).join('\n\n')}`);        }      }    }  }  // Check for status-based queries  const statusKeywords: Record<string, string> = {    "delivered": "Delivered",    "in transit": "In Transit",    "shipped": "Shipped",    "pending": "Order Placed",    "cancelled": "Cancelled",    "out for delivery": "Out for Delivery",    "confirmed": "Confirmed",    "packed": "Packed"  };  for (const [keyword, status] of Object.entries(statusKeywords)) {    if (lowerMessage.includes(keyword)) {      const { data, count } = await supabase        .from('orders')        .select('*', { count: 'exact' })        .eq('order_status', status)        .order('order_date', { ascending: false })        .limit(5);            if (data && data.length > 0) {        results.push(`Found ${count} orders with status "${status}":\n${data.map(formatOrderForDisplay).join('\n\n')}${(count || 0) > 5 ? `\n\n...and ${(count || 0) - 5} more orders.` : ''}`);      }    }  }  // Check for product/brand searches  const productPatterns = ["product", "brand", "item", "buy", "purchase"];  for (const pattern of productPatterns) {    if (lowerMessage.includes(pattern)) {      const searchTerms = userMessage.match(/\b[a-zA-Z]{3,}\b/g);      if (searchTerms) {        for (const term of searchTerms) {          if (!["the", "what", "where", "when", "how", "can", "you", "find", "show", "get", "tell", "about", "order", "tracking", "product", "brand"].includes(term.toLowerCase())) {            const { data } = await supabase              .from('orders')              .select('*')              .or(`product_name.ilike.%${term}%,product_brand.ilike.%${term}%,product_category.ilike.%${term}%`)              .order('order_date', { ascending: false })              .limit(3);                        if (data && data.length > 0) {              results.push(`Found ${data.length} order(s) matching "${term}":\n${data.map(formatOrderForDisplay).join('\n\n')}`);            }          }        }      }    }  }  // Check for location-based queries  const locationPatterns = ["location", "where", "city", "state", "address"];  for (const pattern of locationPatterns) {    if (lowerMessage.includes(pattern)) {      const { data } = await supabase        .from('orders')        .select('*')        .not('current_location', 'is', null)        .order('order_date', { ascending: false })        .limit(5);            if (data && data.length > 0) {        results.push(`Found ${data.length} orders with current location info:\n${data.map(formatOrderForDisplay).join('\n\n')}`);      }    }  }  // Check for statistics queries  if (lowerMessage.includes("statistics") || lowerMessage.includes("stats") || lowerMessage.includes("summary") || lowerMessage.includes("overview") || lowerMessage.includes("how many") || lowerMessage.includes("total")) {    const { data } = await supabase.from('orders').select('order_status, total_amount, product_category, product_brand');        if (data) {      const total = data.length;      const delivered = data.filter(o => o.order_status === 'Delivered').length;      const inTransit = data.filter(o => ['In Transit', 'Shipped', 'Out for Delivery'].includes(o.order_status)).length;      const pending = data.filter(o => ['Order Placed', 'Confirmed', 'Packed'].includes(o.order_status)).length;      const cancelled = data.filter(o => ['Cancelled', 'Returned'].includes(o.order_status)).length;      const totalRevenue = data.reduce((sum, o) => sum + (o.total_amount || 0), 0);            // Category breakdown      const categoryStats = data.reduce((acc, o) => {        acc[o.product_category] = (acc[o.product_category] || 0) + 1;        return acc;      }, {} as Record<string, number>);            // Brand breakdown      const brandStats = data.reduce((acc, o) => {        acc[o.product_brand] = (acc[o.product_brand] || 0) + 1;        return acc;      }, {} as Record<string, number>);            const topCategories = Object.entries(categoryStats)        .sort(([,a], [,b]) => b - a)        .slice(0, 3)        .map(([cat, count]) => `${cat}: ${count}`)        .join(', ');            const topBrands = Object.entries(brandStats)        .sort(([,a], [,b]) => b - a)        .slice(0, 3)        .map(([brand, count]) => `${brand}: ${count}`)        .join(', ');            results.push(`üìä **Order Statistics:**\n- Total Orders: ${total}\n- Delivered: ${delivered}\n- In Transit: ${inTransit}\n- Pending: ${pending}\n- Cancelled: ${cancelled}\n- Total Revenue: ‚Çπ${Math.round(totalRevenue).toLocaleString()}\n- Average Order Value: ‚Çπ${Math.round(totalRevenue / total).toLocaleString()}\n\nüì¶ **Top Categories:** ${topCategories}\n\nüè∑Ô∏è **Top Brands:** ${topBrands}`);    }  }  // Check for tracking queries  if (lowerMessage.includes("tracking") || lowerMessage.includes("track")) {    const { data } = await supabase      .from('orders')      .select('*')      .not('tracking_number', 'is', null)      .order('order_date', { ascending: false })      .limit(5);        if (data && data.length > 0) {      results.push(`Found ${data.length} orders with tracking numbers:\n${data.map(formatOrderForDisplay).join('\n\n')}`);    }  }  // Check for recent orders  if (lowerMessage.includes("recent") || lowerMessage.includes("latest") || lowerMessage.includes("new")) {    const { data } = await supabase      .from('orders')      .select('*')      .order('order_date', { ascending: false })      .limit(5);        if (data && data.length > 0) {      results.push(`Recent orders:\n${data.map(formatOrderForDisplay).join('\n\n')}`);    }  }  return results.join('\n\n---\n\n');}export async function getAIResponse(userMessage: string, conversationHistory: any[] = []): Promise<string> {  try {    // Get relevant order data    const relevantData = await getRelevantOrderData(userMessage);        // Get predictive insights for relevant orders    let predictiveInsights = "";    if (relevantData && relevantData.trim()) {      try {        // Extract order IDs from the relevant data        const orderIds: string[] = [];        const orderIdMatches = relevantData.match(/Order ID: ([^\s]+)/g);        if (orderIdMatches) {          orderIdMatches.forEach(match => {            const orderId = match.replace('Order ID: ', '');            orderIds.push(orderId);          });        }                if (orderIds.length > 0) {          const predictions = await predictiveService.predictDeliveryDelays(orderIds);                    if (predictions.length > 0) {            const highRiskOrders = predictions.filter(p => p.delayProbability > 50);            if (highRiskOrders.length > 0) {              predictiveInsights = `              üö® **PREDICTIVE INTELLIGENCE ALERT** üö®${highRiskOrders.map(p => `‚Ä¢ Order ${p.orderId}: ${p.delayProbability.toFixed(0)}% delay risk  Risk factors: ${p.riskFactors.map(rf => rf.type).join(', ')}  Predicted delivery: ${new Date(p.predictedDeliveryDate).toLocaleDateString()}  Recommendations: ${p.recommendations.slice(0, 2).join(', ')}`).join('')}‚ö° **AI Prediction Summary**: ${highRiskOrders.length} order(s) at risk of delay. Consider proactive customer notification and alternative shipping options.`;            } else {              predictiveInsights = `              ‚úÖ **PREDICTIVE INTELLIGENCE**: All analyzed orders are on track with low delay risk. Current delivery estimates appear reliable based on weather, traffic, and carrier performance data.`;            }          }        }      } catch (predError) {        console.error('Predictive service error:', predError);        // Continue without predictive insights if there's an error      }    }    // Get business insights for business-related queries    let businessInsights = "";    if (userMessage.toLowerCase().includes('business') ||         userMessage.toLowerCase().includes('revenue') ||         userMessage.toLowerCase().includes('sales') ||         userMessage.toLowerCase().includes('customer') ||         userMessage.toLowerCase().includes('product') ||         userMessage.toLowerCase().includes('analytics') ||         userMessage.toLowerCase().includes('insights') ||         userMessage.toLowerCase().includes('performance')) {      try {        const insights = await businessInsightsService.getBusinessInsights();                businessInsights = `üìä **BUSINESS INTELLIGENCE DASHBOARD** üìä**Revenue Overview:**‚Ä¢ Total Revenue: ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(insights.revenue.totalRevenue)}‚Ä¢ Revenue Growth: ${insights.revenue.revenueGrowth.toFixed(1)}%‚Ä¢ Average Order Value: ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(insights.revenue.averageOrderValue)}**Customer Analytics:**‚Ä¢ Total Customers: ${insights.customerBehavior.totalCustomers.toLocaleString()}‚Ä¢ Customer Retention Rate: ${insights.customerBehavior.customerRetentionRate.toFixed(1)}%‚Ä¢ Average Orders per Customer: ${insights.customerBehavior.averageOrdersPerCustomer.toFixed(1)}**Product Performance:**‚Ä¢ Total Products: ${insights.productPerformance.totalProducts}‚Ä¢ Top Product: ${insights.productPerformance.topSellingProducts[0]?.name || 'N/A'}‚Ä¢ Top Category: ${insights.productPerformance.categoryPerformance[0]?.category || 'N/A'}**Geographic Reach:**‚Ä¢ Active Regions: ${insights.geographicSales.totalRegions}‚Ä¢ Top Region: ${insights.geographicSales.topRegions[0]?.region || 'N/A'}**Forecast:**‚Ä¢ Next Month Revenue: ${new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(insights.predictiveForecast.nextMonthRevenue)}‚Ä¢ Growth Trend: ${insights.predictiveForecast.growthTrend}‚Ä¢ Confidence: ${insights.predictiveForecast.confidence.toFixed(0)}%**Key Insights:**${insights.keyInsights.slice(0, 3).map(insight => `‚Ä¢ ${insight}`).join('\n')}**Recommendations:**${insights.recommendations.slice(0, 3).map(rec => `‚Ä¢ ${rec}`).join('\n')}`;      } catch (businessError) {        console.error('Business insights service error:', businessError);        // Continue without business insights if there's an error      }    }    // Handle visual recognition requests    let visualRecognitionInfo = "";    if (userMessage.toLowerCase().includes('scan') ||         userMessage.toLowerCase().includes('recognize') ||         userMessage.toLowerCase().includes('image') ||         userMessage.toLowerCase().includes('photo') ||         userMessage.toLowerCase().includes('receipt') ||         userMessage.toLowerCase().includes('invoice') ||         userMessage.toLowerCase().includes('visual')) {            visualRecognitionInfo = `üì∏ **VISUAL ORDER RECOGNITION** üì∏I can help you extract order information from images! Here's what you can do:**What you can scan:**‚Ä¢ Order receipts and invoices‚Ä¢ Shipping labels and tracking numbers‚Ä¢ Product packaging and labels‚Ä¢ Order confirmation emails‚Ä¢ Purchase orders**How it works:**1. Go to the "Scan" tab in the app2. Take a photo or upload an image3. AI will automatically extract text and order details4. Match with existing orders in our database5. Get instant results and suggestions**Features:**‚Ä¢ OCR text extraction with high accuracy‚Ä¢ Automatic order matching‚Ä¢ Confidence scoring‚Ä¢ Quality analysis‚Ä¢ Smart suggestions**Supported formats:**‚Ä¢ JPEG, PNG, WebP images‚Ä¢ Maximum file size: 10MB‚Ä¢ Camera capture or gallery uploadTry it now! Navigate to the Scan tab and upload your order document.`;    }      // Define Order interface    interface Order {      id?: string;      order_id?: string;      customer_name?: string;      customer_email?: string;      customer_phone?: string;      customer_address?: string;      customer_city?: string;      customer_state?: string;      customer_pincode?: string;      order_date?: string;      order_status?: string;      order_total?: number;      payment_status?: string;      payment_method?: string;      shipping_method?: string;      tracking_number?: string;      carrier_name?: string;      current_location?: string;      expected_delivery?: string;      actual_delivery?: string;      items?: any[];      quantity?: number;      total_amount?: number;      tax_amount?: number;      shipping_amount?: number;      discount_amount?: number;      notes?: string;      created_at?: string;      updated_at?: string;      is_deleted?: boolean;      deleted_at?: string | null;      deleted_by?: string | null;      status_history?: any[];      delivery_attempts?: number;      signature_required?: boolean;      signature_url?: string;      delivery_instructions?: string;      is_gift?: boolean;      gift_message?: string;    }    // Parse order data if available    let orderData: Order = {};    try {      if (relevantData) {        orderData = JSON.parse(relevantData);      }    } catch (e) {      console.error('Error parsing order data:', e);    }    const systemPrompt = `You are ARKIO, an advanced AI assistant for order tracking and customer support. You are professional, empathetic, and detail-oriented. Your responses MUST follow this exact structure:1. ORDER DETAILS2. ORDER SUMMARY3. SHIPPING & TRACKING4. WHAT THIS MEANS5. IF PACKAGE NOT RECEIVED6. NEXT STEPS & SUPPORT7. IN SHORTAlways connect with the database and include relevant data in your responses. Use emojis for better readability.`;    // Helper function to format date    const formatDate = (dateString?: string): string => {      if (!dateString) return 'N/A';      try {        return new Date(dateString).toLocaleDateString('en-US', {          year: 'numeric',          month: 'short',          day: 'numeric',          hour: '2-digit',          minute: '2-digit'        });      } catch (e) {        return dateString;      }    };    // Format order for display    const formatOrderForDisplay = (order: Order): string => {      return `        ‚Ä¢ **Order ID:** ${order.order_id || 'N/A'}        ‚Ä¢ **Status:** ${order.order_status || 'N/A'}        ‚Ä¢ **Order Date:** ${order.order_date ? formatDate(order.order_date) : 'N/A'}        ‚Ä¢ **Customer:** ${order.customer_name || 'N/A'}        ‚Ä¢ **Items:** ${order.quantity || 0} item${order.quantity !== 1 ? 's' : ''}`;    };    // Build the user message with structured data    const userMessageContent = `# 1Ô∏è‚É£ ORDER DETAILSüì¶ **Order Information**${relevantData ? formatOrderForDisplay(orderData) : 'No order data available'}# 2Ô∏è‚É£ ORDER SUMMARYüìù **Quick Overview**‚Ä¢ **Order Status:** ${orderData.order_status || 'N/A'}‚Ä¢ **Last Updated:** ${orderData.updated_at ? formatDate(orderData.updated_at) : 'N/A'}‚Ä¢ **Total Items:** ${orderData.quantity || 'N/A'}‚Ä¢ **Order Total:** ‚Çπ${orderData.total_amount || 'N/A'}# 3Ô∏è‚É£ SHIPPING & TRACKINGüöö **Delivery Information**‚Ä¢ **Tracking #:** ${orderData.tracking_number || 'Not available'}‚Ä¢ **Carrier:** ${orderData.carrier_name || 'Not specified'}‚Ä¢ **Current Location:** ${orderData.current_location || 'In transit'}‚Ä¢ **Expected Delivery:** ${orderData.expected_delivery ? formatDate(orderData.expected_delivery) : 'Not available'}# 4Ô∏è‚É£ WHAT THIS MEANSüí° **Understanding Your Order Status**‚Ä¢ ${getStatusExplanation(orderData.order_status)}‚Ä¢ ${getNextExpectedAction(orderData.order_status)}# 5Ô∏è‚É£ IF YOU HAVEN'T RECEIVED YOUR PACKAGE‚ö†Ô∏è **Missing Package?**If your order hasn't arrived by the expected delivery date, please select an option:1. **Initiate Delivery Investigation**   - We'll contact the carrier   - Check for delivery exceptions   - Provide resolution within 24-48 hours2. **Request Replacement/Refund**   - Start return process   - Check refund eligibility   - Process replacement order3. **Get Proof of Delivery**   - Request signature confirmation   - Check delivery location   - Verify delivery time4. **Contact Support**   - Speak with an agent   - Get immediate assistance   - Escalate urgent matters# 6Ô∏è‚É£ NEXT STEPS & SUPPORTüìû **How Can We Help?**Please select an option or type your question:1. **Track Another Order**2. **Update Delivery Instructions**3. **Change Shipping Address**4. **Report an Issue**5. **Speak to Support**# 7Ô∏è‚É£ IN SHORT‚úÖ ${orderData.order_id ? `Order ${orderData.order_id} is ${orderData.order_status?.toLowerCase() || 'processing'}. ${getQuickSummary(orderData)}` : 'Processing your request...'}`;    // Prepare the messages array for the API call    const messages: Array<{ role: string; content: string }> = [      { role: 'system', content: systemPrompt },      { role: 'user', content: userMessageContent }    ];    // Add conversation history if available    if (conversationHistory && conversationHistory.length > 0) {      messages.unshift(...conversationHistory.slice(-5)); // Add last 5 messages for context    }    // Make the API call to OpenRouter    try {      const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {        method: 'POST',        headers: {          'Authorization': `Bearer ${OPENROUTER_API_KEY}`,          'Content-Type': 'application/json',        },        body: JSON.stringify({          model: MODEL,          messages: messages,          max_tokens: 1000,          temperature: 0.7,        }),      });      if (!response.ok) {        const errorData = await response.json();        console.error('OpenRouter API error:', errorData);        throw new Error(`API request failed with status ${response.status}`);      }      const data = await response.json();      return data.choices[0]?.message?.content || 'I apologize, but I encountered an issue processing your request.';    } catch (error) {      console.error('Error calling OpenRouter API:', error);      return 'I apologize, but I encountered an error while processing your request. Please try again later.';    }  }}
